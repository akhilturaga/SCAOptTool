import pandas as pd
import random

#Created by: Akhil Turaga

"""SINGLE-CELL ANALYSIS OPTIMIZATION TOOL

This program allows the user to find the superceding node for a single or series of input genes. The user is first 
prompted to enter a gene or series of genes into the console. The program reads gene expression data and cell types 
from csv files that are pre-populated with data from the CIBERSORTx LM22 Signature Matrix file and 
confidence scores generated by STRING to first predict the cell type that the gene belongs to. It 
then proceeds to traverse through the network of nodes and compares confidence scores until 
a superceding node is found. This logic is based on the assumption that the input network is an undirected, 
bidirectional graph.

"""

def train_test_split(data, test_size=0.2):
    """
    Splits the data into training and testing sets.

    Args:
        data (list): The data to split.
        test_size (float): The proportion of the data to include in the test set.

    Returns:
        tuple: The training and testing sets, each as a list of data points.
    """
    n_test = int(len(data) * test_size)
    random.shuffle(data)
    return data[n_test:], data[:n_test]

# User enters gene names
input_genes = input("Enter one or more gene names separated by commas: ").split(',')

# Load the adjacency matrix from a file
adj_matrix = pd.read_csv('adj_matrix.csv', index_col=0)

# Convert the matrix to a list of tuples
data = [tuple(row) for _, row in adj_matrix.iterrows()]

# Split the data into training and testing sets
train_set, test_set = train_test_split(data)

# Convert the sets back to pandas DataFrames if needed
train_df = pd.DataFrame(train_set, columns=adj_matrix.columns)
test_df = pd.DataFrame(test_set, columns=adj_matrix.columns)

# Defines a function to predict the cell type for a set of input genes
def predict_cell_type(input_genes):
    # Filters the gene expression data to include only the expression data of the input genes
    input_data = adj_matrix[input_genes]
    
    # Finds the row with the maximum value for each sample (cell)
    cell_types = input_data.idxmax(axis=1)
    
    # Returns a list of predicted cell types for each sample (cell)
    print(cell_types)
    return list(cell_types)

# Finds the highest scoring superceding node for a set of input genes
def find_superceding_node(input_genes):
    # Load the network data
    network = pd.read_csv('gene_network.csv')
    
    # Define a dictionary to store the superceding nodes for each input gene
    superceding_nodes = {}
    
    # Loop over each input gene
    for gene in input_genes:
        superceding_node_weight = 0 
        # Finds the connections for the current gene
        connections = network[((network['Node 1'] == gene) | (network['Node 2'] == gene)) & (network['combined_score'] > 0.6)]
        
        # If connections exist
        if not connections.empty:
            # Finds the highest scoring connection for the current gene
            highest_scoring_connection = connections.loc[connections['combined_score'].idxmax()]
            
            # Determines the superceding node for the current gene
            if highest_scoring_connection['Node 1'] == gene:
                superceding_node = highest_scoring_connection['Node 2']
            else:
                superceding_node = highest_scoring_connection['Node 1']
            
            # Loop over the next superceding nodes until a superceding node with a higher weight is found
            while True:
                # Finds the connections for the current superceding node
                connections = network[((network['Node 1'] == superceding_node) | (network['Node 2'] == superceding_node)) & (network['combined_score'] > 0.6)]
                print(connections)
                # If connections exist
                if not connections.empty:
                    # Finds the highest scoring connection for the current superceding node
                    highest_scoring_connection = connections.loc[connections['combined_score'].idxmax()]
                    
                    # Determines the next superceding node based on the highest scoring connection
                    if highest_scoring_connection['Node 1'] == superceding_node:
                        next_superceding_node = highest_scoring_connection['Node 2']
                    else:
                        next_superceding_node = highest_scoring_connection['Node 1']
                    
                    # If the weight of the highest scoring connection for the next superceding node is higher than the current superceding node
                    if highest_scoring_connection['combined_score'] > superceding_node_weight:
                        # Update the superceding node and weight if the next superceding node has a higher weight
                        superceding_node = next_superceding_node
                        superceding_node_weight = highest_scoring_connection['combined_score']
                    else:
                        # Ends the loop if the next superceding node has a lower or equal weight
                        break
                    print(superceding_node)
                else:
                    # Ends the loop if no more connections are found for the current superceding node
                    break
           
            #Adds the superceding node to the dictionary
            superceding_nodes[gene] = superceding_node
   
    return superceding_nodes

#Calls the function to find the highest scoring superceding node for the input gene(s)
superceding_nodes = find_superceding_node(input_genes)
print(superceding_nodes)


"""Former code for predicting the cell type for an input gene, does not implement ML"""
# gene = input("Enter gene: ")
# exp_matrix = {
#   "row1": [420, 3, 39],
#   "row2": [5, 40, 4]
# }
# df = pd.DataFrame(exp_matrix)
# df.columns =['B-Cell', 'T-Cell']
# df.index = ['GENE1', 'GENE2', 'GENE3']

# #Finds associated cell cluster based on max expression value
# row = (df.loc[[gene]])
# cellExp = row.idxmax(axis=1).iloc[0]
# print("Gene " + gene + ", has the highest expression in " + row.idxmax(axis=1).iloc[0])
