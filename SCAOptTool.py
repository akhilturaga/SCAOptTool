import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier

#Created by: Akhil Turaga

"""SINGLE-CELL ANALYSIS OPTIMIZATION TOOL

This program allows the user to find the superceding node for a single or series of input genes 
using scikit-learn, a Python-based, open-source machine learning library. The user is first prompted to 
enter a gene or series of genes into the console. The program reads gene expression data and cell types 
from csv files that are pre-populated with data from the CIBERSORTx LM22 Signature Matrix file and 
confidence scores generated by STRING to first predict the cell type that the gene belongs to. It 
then proceeds to traverse through the network of nodes and compares confidence scores until 
a superceding node is found. This logic is based on the assumption that the input network is an undirected, 
bidirectional graph.

"""

#User enters gene names
input_genes = input("Enter one or more gene names separated by commas: ").split(',')

#Loads the gene expression data and cell type label csv files
adj_matrix = pd.read_csv('adj_matrix.csv')
cell_labels = pd.read_csv('cell_type_labels.csv')

#Splits the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(adj_matrix, cell_labels)

#Train a random forest classifier on the training data, currently 100 decision trees with a max depth 
# of 10, can be modified later based on specific training data
classifier = RandomForestClassifier(n_estimators = 100, max_depth = 10, random_state = 50)
classifier.fit(X_train, y_train)

#Predicts the cell type for a set of input genes
def predict_cell_type(input_genes):
    # Filters the gene expression data to include only the expression data of the input genes
    input_data = adj_matrix[input_genes]
    #Predicts using the trained classifier
    cell_type = classifier.predict(input_data)
    return cell_type

#Finds the highest scoring superceding node for a set of input genes
def find_superceding_node(input_genes):

    #Finds the highest scoring superceding node for each input gene, stores in dictionary
    superceding_nodes = {}
    for gene in input_genes:
        #Finds the connections for the current gene
        connections = network[(network['node1'] == gene) | (network['node2'] == gene)]
    
        #If connections exist
        if connections.empty == False:
            #Finds the highest scoring connection for the current gene
            highest_scoring_connection = connections.loc[connections['weight'].idxmax()]
           
            #Determines the superceding node for the current gene
            if highest_scoring_connection['node1'] == gene:
                superceding_node = highest_scoring_connection['node2']
            else:
                superceding_node = highest_scoring_connection['node1']
           
            #Checks if any connections exist for the current superceding node
            if not connections.empty:
                #Finds the highest scoring connection for the current superceding node
                highest_scoring_connection = connections.loc[connections['weight'].idxmax()]
                
                #Determines the next superceding node based on the highest scoring connection
                if highest_scoring_connection['node1'] == superceding_node:
                    next_superceding_node = highest_scoring_connection['node2']
                else:
                    next_superceding_node = highest_scoring_connection['node1']
                
                #Checks if the weight of the highest scoring connection for the next superceding node is higher than the current superceding node
                if highest_scoring_connection['weight'] > superceding_node_weight:
                    # Update the superceding node and weight if the next superceding node has a higher weight
                    superceding_node = next_superceding_node
                    superceding_node_weight = highest_scoring_connection['weight']
                else:
                    #Ends the loop if the next superceding node has a lower or equal weight
                    break
            else:
                #Ends the loop if no more connections are found for the current superceding node
                break
           
            #Adds the superceding node to the dictionary
            superceding_nodes[gene] = superceding_node
   
    return superceding_nodes

#Calls the function to find the highest scoring superceding node for the input gene(s)
superceding_nodes = find_superceding_node(input_genes)
print(superceding_nodes)

"""Former code for predicting the cell type for an input gene, does not implement ML"""
# gene = input("Enter gene: ")
# exp_matrix = {
#   "row1": [420, 3, 39],
#   "row2": [5, 40, 4]
# }
# df = pd.DataFrame(exp_matrix)
# df.columns =['B-Cell', 'T-Cell']
# df.index = ['GENE1', 'GENE2', 'GENE3']

# #Finds associated cell cluster based on max expression value
# row = (df.loc[[gene]])
# cellExp = row.idxmax(axis=1).iloc[0]
# print("Gene " + gene + ", has the highest expression in " + row.idxmax(axis=1).iloc[0])